---
title: "Data 101"
subtitle: "Introduzione al Data Management"
author: "Isac Pasianotto"
date: "12 December 2025"
format:
  revealjs:
    footer: "Isac Pasianotto - 12/12/2025"
    theme: ./mytheme.css
    # theme: [dracula, mytheme.css]
    transition: slide
    scrollable: true
    smaller: false
    toc: true
    toc-depth: 1
    toc-title: "Agenda"
    slide-number: true
    self-contained: true
    pdf-separate-fragments: true
    notes: false
    code-line-numbers: false
---

# Concetti introduttivi

## Dato vs informazione?

::: {.columns}
:::: {.column width="33%"}
<div class="fragment" data-fragment-index="1">
<img src="img/finland1.png" width="75%" style="display: block; margin-left: auto; margin-right: auto;">
</div>
::::

:::: {.column width="33%"}
<div class="fragment" data-fragment-index="2">
<img src="img/finland2.png" width="75%" style="display: block; margin-left: auto; margin-right: auto;">
</div>
::::

:::: {.column width="33%"}
<div class="fragment" data-fragment-index="3">
<img src="img/finland3.png" width="75%" style="display: block; margin-left: auto; margin-right: auto;">
</div>
::::
:::

<br>

::: {.columns}
:::: {.column width="33%"}
<div class="fragment" data-fragment-index="4">
giorni feriali
</div>
::::

:::: {.column width="33%"}
<div class="fragment" data-fragment-index="4">
sabato/pre-festivi
</div>
::::

:::: {.column width="33%"}
<div class="fragment" data-fragment-index="4">
giorni festivi
</div>
::::
:::

## Dato vs informazione?

::: {.fragment .fade-in style="font-size: 80%;"}
- ***Informazione***: Notizia o elemento nozionistico acquisito mediante un vettore (es. studio, osservazione, comunicazione, ...) che consente di avere una conoscienza su un fenomeno o un contesto.
:::

::: {.fragment .fade-in style="font-size: 80%;"}
- ***Dato***: Rappresentazione di un'informazione in forma codificata, adatta per la comunicazione, l'elaborazione o l'archiviazione.
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-note title="Nota"}
Il dato di per sè non ha un significato, ma lo acquisisce solo nel momento in cui viene interpretato e contestualizzato, diventando così informazione.
:::
:::

## Dato vs informazione?

\

::: {.columns}
:::: {.column width="50%"}
![](img/finland1.png){style="display: block; margin-left: auto; margin-right: auto;"}
::::

:::: {.column width="50%"}
\ 

_"Divieto di sosta dalle 08:00 alle 17:00 nei giorni feriali"_
::::
:::

<br>

::: {.columns}
:::: {.column width="50%" style="text-align: center;"}
*Dato*
::::

:::: {.column width="50%" style="text-align: center;"}
*Informazione*
::::
:::

## La rappresentazione dei dati conta!

\ 

::: {.fragment .fade-in style="font-size: 100%; text-align: center;"}
**100100111101001101**
:::

::: {.fragment .fade-in style="font-size: 80%;"}
Che numero è?
:::

::: {.fragment .fade-in style="font-size: 80%;"}
| Rappresentazione | Valore  |
|------------------|---------|
| Naturale         | 37,843  |
| Intero           | -27,263 |
| Floating point   | 9.55e-4 |
:::

## Database

::: {.fragment .fade-in}
::: {.callout-note title="Database: definizione"}
Collezione organizzata e strutturata di dati, registrati in un qualsiasi supporto che ne consente l'accesso per una applicazione o organo di gestione.
:::
:::

\

::: {.fragment .fade-in style="font-size: 80%;"}
- Registro cartaceo
- File di testo
- Collezione di oggetti digitali 
- ...
:::

## DataBase Management System (DBMS)

::: {.fragment .fade-in}
::: {.callout-note title="DBMS: definizione"}
Software che consente la gestione, l'organizzazione e la manipolazione di un una grande collezione di dati (database).
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
- **Dimensioni**: la dimensione dei dati gestiti è molto superiore alla memoria centrale disponibile.
- **Persistenza**: i dati devono essere memorizzati in modo permanente su memoria di massa, resistendo quindi a spegnimenti, crash, ecc.
- **Concorrenza e Condivisione**: più utenti e/o applicativi possono accedere contemporaneamente ai dati.
:::


## DataBase Management System (DBMS)

Un DBMS _deve_ garantire: 

::: {.fragment .fade-in style="font-size: 80%;"}
- **Affidabilità**: i dati devono essere memorizzati in modo sicuro e protetto da guasti hardware o software.
:::
::: {.fragment .fade-in style="font-size: 80%;"}
- **Access control**: i dati devono essere protetti da accessi non autorizzati.
:::
::: {.fragment .fade-in style="font-size: 80%;"}
- **Integrità**: i dati devono essere consistenti e validi secondo delle regole pre-definite.
:::
::: {.fragment .fade-in style="font-size: 80%;"}
- **Efficienza**: le operazioni di accesso e manipolazione dei dati devono essere eseguite in modo rapido ed efficiente.
:::


## Ciclo di vita dei dati

::: {.fragment .fade-in}
::: {.callout-note title="Ciclo di vita dei dati"}
Insieme delle fasi che un dato attraversa dalla sua creazione alla sua eliminazione
:::
:::

::: {.r-stack .fade-in style="font-size: 80%;"}


![](img/ciclo-dato1.png){.fragment width="100%"}

![](img/ciclo-dato2.png){.fragment width="100%"}

:::

## DBMS - componenti

::: {.columns}
:::: {.column width="50%"}

![](img/db-architettura.png){width="100%"}
::::

:::: {.column width="50%"}

::: {.fragment .incremental .fade-in style="font-size: 80%;"}

 - ***Schema interno***: Rappresentazione dello schema logico per mezzo di strutture di memorizzazione (es, file xml, binari, ...)
 - ***Schema logico***: Come è organizzato il database; esistono diverse soluzioni: (gerarchico, reticolare, relazionale, a oggetti, ...)
 - ***Vista***: (schema esterno): Rappresentazione parziale del database, personalizzata per un particolare utente o applicazione.

:::

:::
:::


## Data Base Systems


::: {.fragment .fade-in style="font-size: 80%;"}
***Software:***
:::
::: {.fragment .fade-in style="font-size: 70%;"}
  -  **DBMS**: interposto tra utente/applicazione e database, gestisce l'accesso ai dati.
  - **Utility di supporto** per operazioni di sviluppo e/o backup
:::

::: {.fragment .fade-in style="font-size: 80%;"}
***Utenti coinvolti:***
:::

::: {.fragment .fade-in style="font-size: 70%;"}
- Progettista del DB
- Amministratore del DB
- Sviluppatore di applicazioni
- Utente finale
:::

::: {.fragment .fade-in style="font-size: 60%;"}
- - -
- Schemi (struttura dei dati)
- Hardware utilizzato 
:::

## Il vero vantaggio 

\

::: {.fragment .fade-in style="font-size: 140%; text-align: center;"}
***INDIPENDENZA DEI DATI DALL'APPLICAZIONE***
:::

\

::: {.fragment .fade-in style="font-size: 80%;"}
La logica del programma è indipentende dalla gestione dei dati!
:::

---

# Modello Relazionale 

## Schema logico relazionale:

::: {.fragment .fade-in style="font-size: 80%;"}
Le *12 regole di Codd* (1970) definiscono le caratteristiche che un DBMS relazionale deve avere:
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="\ 1 -  Informazioni"}
Tutte le informazioni in un DBR sono rappresentate esplicitamente da valori in tabelle.
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="\ 2 -  Garanzia di accesso"}
Ogni valore in un DBR è accessibile tramite la combinazione del nome della tabella, del nome della colonna e della chiave primaria.
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="\ 3 -  Rappresentazione sistematica dei valori null"}
Il DBR supporta la rappresentazione di valori null (mancanti o non applicabili) in modo sistematico e distinto da altri valori.
:::
:::

---

## Le 12 regole di Codd (continua)

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="4 – System table"}
Un database relazionale deve essere strutturato logicamente come i dati e gestibile con lo stesso linguaggio.
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="5 – Linguaggio di dati e di manipolazione"}
Un DBR può supportare diversi linguaggi, ma deve supportare un linguaggio “English-like” (→ SQL), in cui sia possibile: 1. Definire dati 2. Manipolare dati 3. Definire viste 4. Gestire l’integrità
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="6 – Aggiornamenti basati su viste"}
Tutte le viste che sono logicamente aggiornabili devono essere aggiornabili tramite il DBR (cruciale per i campi calcolati).
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="7 – Inserimenti, aggiornamenti dei dati da linguaggio"}
Inserire e aggiornare devono avere la stessa logica “a righe” dell’estrazione *(set-oriented approach)*.
:::
:::

---

## Le 12 regole di Codd (continua)

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="8 – Indipendenza dei dati fisici"}
I programmi applicativi non devono sentire alcuna modifica fatta sul metodo e la locazione fisica dei dati.
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="9 – Indipendenza dei dati logici"}
Le modifiche al livello logico non devono richiedere cambiamenti non giustificati alle applicazioni che utilizzano il database.
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="10 – Integrità"}
Tutte le regole di integrità devono essere specificate nel linguaggio di definizione dei dati e applicate dal DBR.
:::
:::

## Le 12 regole di Codd (continua)


::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="11 – Distribuzione"}
La distribuzione di porzioni del database su una o più allocazione fisiche o geografiche deve essere invisibile agli utenti del sistema.
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="12 – Prevenzione accessi non autorizzati"}
Garantisce l’impossibilità di bypassare le regole di
integrità e di accesso ai dati.
:::
:::

## Modello relazionale - concetti base

::: {.fragment .fade-in}
***"Relazione"***: lemma infelice nella lingua italiana, che raccoglie due concetti distinti:
:::

\

::: {.fragment .fade-in}
***Relation***: relazione matematica, concetto che deriva dalla teoria degli insiemi.
:::

\ 

::: {.fragment .fade-in}
***Relationship***: collegamento logico tra entità.
:::

## Relazione: relation 

::: {.fragment .fade-in style="font-size: 80%;"}
Siano $D_1,\ D_2,\ \dots,\ D_n$ $n$ insiemi anche distinti detti **domini**.
:::


::: {.fragment .fade-in style="font-size: 80%;"}
Sia $D$ il **Prodotto cartesiano** dei domini:  
$D = D_1 \times D_2 \times \dots \times D_n$  


ovvero l'insieme delle $n$-tuple $(d_1, d_2, \dots, d_n)$ con $d_i \in D_i$ per $i = 1, 2, \dots, n$.
:::

\

::: {.fragment .fade-in style="font-size: 80%;"}
Una **relazione** $R$ su $D_1, D_2, \dots, D_n$ è un sottoinsieme di $D$, ovvero $R \subseteq D$.
:::

## Relation: proprietà

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Non esistono ordinamenti tra le tuple di una relazione.
- Tutte le tuple di una relazione sono distinte (non esistono duplicati).
- L'ordine degli attributi (colonne) è irrilevante.
- Ogni attributo (colonna) ha un dominio associato.
:::

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Una tabella è una relazione se: 

- I valori di ogni colonna sono omogenei.
- Le righe sono diverse fra loro. 
- Le intestazioni delle colonne sono diverse fra loro
:::


## Relation: esempio 

\


| Casa  |  Trasferta | Goal Casa | Goal Trasferta |
|-------|------------|-----------|----------------|
| Inter | Milan      | 2         | 1              |
| Roma  | Lazio      | 3         | 0              |
| Napoli| Inter      | 1         | 1              |
| Milan | Roma       | 0         | 2              |


## Relationship 

Collegamento logico tra entità di tabelle diverse.

\

![](./img/relationship.png){width="80%" style="display: block; margin-left: auto; margin-right: auto;"}

## Modello relazionale - concetti base

::: {.fragment .fade-in}
::: {.callout-note title="Vincoli di integrità"}
Regole che garantiscono la correttezza e la coerenza dei dati all'interno di un database relazionale, possono essere:
- Vincoli di dominio
- Vincoli di n-upla
- Vincoli referenziali
:::
:::

::: {.fragment .fade-in}
::: {.callout-note title="Chiave primaria"}
Attributo o insieme di attributi che identificano univocamente una tupla all'interno di una relazione.
:::
:::

::: {.fragment .fade-in}
::: {.callout-note title="Chiave esterna"}
Attributo o insieme di attributi in una relazione che fa riferimento alla chiave primaria di un'altra relazione, stabilendo un collegamento tra le due tabelle.
:::
:::

## Chiavi: definizioni

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-note title="***Def.*** Superchiave"}
Sia $K$ insieme di attributi di una relazione $R$, ovvero: 
$k \in K,\ k = (d_1^k, d_2^k, \dots, d_n^k) \subseteq R$.

$K$ è una **superchiave** per $R$ se $\forall t_1, t_2 \in R : t_1 \neq t_2 \Rightarrow t_1[K] \neq t_2[K]$. 

"Non esistono due tuple distinte che abbiano gli stessi valori per gli attributi in $K$."
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-note title="***Def.*** Superchiave minimale"}
Sia $K$ una superchiave per $R$.

$K$ è una **superchiave minimale o candidata** per $R$ se $\nexists K^* \subset K$ tale che $K^*$ sia una superchiave per $R$.
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
La **chiavi primaria** è **una fra le possibili superchiavi minimali**, scelta per identificare univocamente le tuple di una relazione.
:::

## SQL - Structured Query Language

Metalinguaggio standard per la gestione e manipolazione di database relazionali.

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Linguaggio dichiarativo: si specifica *cosa* si vuole ottenere, non *come* ottenerlo[^1].
- consente di:
  - Definire strutture di dati (DDL)
  - Manipolare dati (DML)
  - Controllare l'accesso ai dati (DCL)

[^1]: Ma avere idea di che succede sotto il cofano aiuta molto! E.g., ottimizzazione delle query studiando il QEP (Query Execution Plan).
:::

## SQL - Esempio

```sql
SELECT
    c.name,
    SUM(o.amount) AS total_spent
FROM customers c
JOIN orders o ON o.customer_id = c.id
WHERE o.order_date >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY c.name
HAVING SUM(o.amount) > 500
ORDER BY total_spent DESC;
```

## Transizioni

::: {.fragment .incremental .fade-in style="font-size: 80%;"}

- Transazioni: unità logica di lavoro che può comprendere una o più operazioni di database.
- Vengono usate quando è necessario garantire che un insieme di operazioni vengano eseguite in modo atomico.
- Il risultato di una transazione deve essere tale che il database rimanga in uno stato consistente
- Vuol dire che *tutte* le operazioni della transazione vengono completate con successo, o *nessuna* viene applicata (proprietà ACID).
:::


## Transazione - esempio
::: {style="font-size:60%;"}
```sql
BEGIN; -- Inizio della transazione
SET LOCAL my.beneficiario = '2001';    -- variabili di sessione
SET LOCAL my.debitore = '3001';
SET LOCAL my.n_prelievo = (SELECT MAX(id) + 1 FROM prelievi)::INT;
SET LOCAL my.n_deposito = (SELECT MAX(id) + 1 FROM versamenti)::INT;
SET LOCAL my.importo = '150.00'; 
INSERT INTO prelievi(id, conto, importo, data_operazione)    --registrazione prelievo
VALUES (
    current_setting('my.n_prelievo')::INT,
    current_setting('my.debitore')::INT,
    current_setting('my.importo')::NUMERIC,
    NOW()
);
INSERT INTO versamenti(id, conto, importo, data_operazione)    --registrazione deposito
VALUES (
    current_setting('my.n_deposito')::INT,
    current_setting('my.beneficiario')::INT,
    current_setting('my.importo')::NUMERIC,
    NOW()
);
UPDATE saldo_clienti   -- aggiornamento saldi
SET saldo = saldo + current_setting('my.importo')::NUMERIC
WHERE conto = current_setting('my.beneficiario')::INT;
UPDATE saldo_clienti
SET saldo = saldo - current_setting('my.importo')::NUMERIC
WHERE conto = current_setting('my.debitore')::INT;
COMMIT; -- Fine della transazione
```
:::

## ACID: le transazioni in un db relazionale

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Ogni transazione in un DBMS relazionale deve rispettare le proprietà ACID:
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="A - Atomicity (Atomicità)"}
Tutte le operazioni all'interno di una transazione devono essere completate con successo affinché la transazione sia considerata completata. Se una qualsiasi operazione fallisce, l'intera transazione deve essere annullata (rollback).
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="C - Consistency (Consistenza)"}
Una transazione deve portare il database da uno stato consistente a un altro stato consistente, rispettando tutte le regole di integrità definite nel database.
:::
:::

## ACID: le transazioni in un db relazionale 

::: {.callout-tip title="I - Isolation (Isolamento)"}
Le operazioni di una transazione devono essere isolate dalle operazioni di altre transazioni in esecuzione contemporaneamente, in modo che il risultato finale sia lo stesso come se le transazioni fossero eseguite in sequenza.
:::


::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="D - Durability (Durabilità)"}
Una volta che una transazione è stata completata con successo, le modifiche apportate al database devono essere permanenti, anche in caso di guasti di sistema.
:::
:::

# No-SQL

## Cenni storici

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- **1970**: Edgar F. Codd pubblica il modello relazionale.
- **anni 80**: diffusione dei DB relazionali *commerciali*:  Oracle(1979), IBM DB2 (1983), Microsoft SQL Server (1989) ...
- **anni 90**: primi DB relazionali *open-source*: MySQL (1995), PostgreSQL (1996) ...
:::

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Andava tutto bene...
:::


::: {.fragment .fade-in style="font-size: 80%;"}
SQL per molit anni è stato lo standard de facto per la gestione dei dati.
:::

## No-SQL: la nascita

::: {.fragment .fade-in style="font-size: 80%;"}
Nel tempo le esigenze di gestione dei dati sono cambiate:
:::

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Grandi volumi di dati da gestire (Big Data)
- Necessità di scalabilità orizzontale
- Struttura dei dati troppo rigida per determinati domini applicativi
:::

::: {.fragment .fade-in style="font-size: 80%;"}
I database No-SQL nascono per rispondere a queste nuove esigenze.
:::

## No-SQL DB:

::: {.callout-note title='“No-SQL”'}
No-SQL: **Not Only SQL**; termine ombrello usato per descrivere una varietà di sistemi di gestione dei dati non relazionali.
:::

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Termine nato nel 1998 da Carlo Strozzi per indicare un DBMS che non utilizzava SQL.
- Diventato popolare nel 2009, a seguito di un evento organizzato da Johan Oskarsson.
- Oggi racchiude una vasta gamma di tecnologie di database la cui unica caratteristica comune è quella di non essere basate sul modello relazionale.
:::

## BASE: l'alternativa al paradigma ACID

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Le transazioni nei DB No-SQL spesso seguono il paradigma BASE:
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="BA - Basically Available"}
Il sistema garantisce la disponibilità dei dati, anche in caso di guasti o partizioni di rete.
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="S - Soft state"}
Il sistema non garantisce che lo stato dei dati sia sempre consistente, ma può essere in uno stato intermedio; questo implica che il sistema possa modificare lo stato dei dati nel tempo, anche senza input esterni.
:::
:::

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-tip title="E - Eventual consistency"}
Il sistema garantisce che alla fine, prima o poi, tutti i nodi del sistema convergeranno verso uno stato consistente.
:::
:::

## Tipi di database No-SQL

::: {.fragment .fade-in style="font-size: 80%;"}
Come già anticipato i DB No-SQL sono estremamente eterogenei, e classificarli in delle categorie non è semplice.

Generalmente vengono proposte le seguenti categorie basate sul modello di dati utilizzato:
:::

<!-- ::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- ***a. Key-Value***  (e.g., ETCD, Amazon DynamoDB)
- ***b. Document-based*** (e.g., MongoDB, CouchDB)
- ***c. Column-family*** (e.g, QuestDB, Cassandra, Bigtable)
- ***d. Graph-based*** (e.g., Neo4j, Amazon Neptune)
- ***e. In memory*** (e.g., Redis, Memcached)
::: -->

<table style="font-size:90%; width:100%;">
  <tr class="fragment fade-in">
    <td style="text-align:left;   width:10%;">a.</td>
    <td style="text-align:left;   width:35%;">Key-Value</td>
    <td style="text-align:right;  width:55%;">ETCD, Amazon DynamoDB</td>
  </tr>

  <tr class="fragment fade-in">
    <td style="text-align:left;">b.</td>
    <td style="text-align:left;">Document-based</td>
    <td style="text-align:right;">MongoDB, CouchDB</td>
  </tr>

  <tr class="fragment fade-in">
    <td style="text-align:left;">c.</td>
    <td style="text-align:left;">Column-family</td>
    <td style="text-align:right;">QuestDB, Cassandra, Bigtable</td>
  </tr>

  <tr class="fragment fade-in">
    <td style="text-align:left;">d.</td>
    <td style="text-align:left;">Graph-based</td>
    <td style="text-align:right;">Neo4j, Amazon Neptune</td>
  </tr>

  <tr class="fragment fade-in">
    <td style="text-align:left;">e.</td>
    <td style="text-align:left;">In-memory</td>
    <td style="text-align:right;">Redis, Memcached</td>
  </tr>
</table>


## a. Key-Value DB

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Un'unica tabella di due colonne:

- **Key**: identificatore univoco per ogni elemento.
- **Value**: dato associato alla chiave, può essere di qualsiasi tipo (stringa, numero, oggetto complesso, ...).
:::

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Esempio di operazioni:

- PUT(key, value): inserisce o aggiorna il valore associato alla chiave.
- GET(key): recupera il valore associato alla chiave.
- DELETE(key): rimuove la coppia chiave-valore.
:::

## a. Key-Value DB 

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Vantaggi: 
  - Estremamente efficienti per operazioni di lettura/scrittura semplici.
  - Facilità di gestione 
  - Scalabilità orizzontale
- Svantaggi:
  - Non adatti a dati complessi 
  - Mancanza di funzionalità avanzate per query complesse
:::

## b. Document-based DB

::: {.columns}
:::: {.column width="50%"}


\

\ 

![](./img/document-db.png){.fragment width="100%"}

::::
:::: {.column width="50%"}

::: {.fragment .incremental .fade-in style="font-size: 75%;"}
Simili ai Key-Value, ma il valore è un documento (JSON, ma anche XML, BSON, ...).
:::

::: {.fragment .incremental .fade-in style="font-size: 75%;"}
Esempio di operazioni:

- INSERT(document): inserisce un nuovo documento.
- FIND(query): recupera documenti che soddisfano una query.
- UPDATE(query, update): aggiorna documenti che soddisfano una query.
- DELETE(query): rimuove documenti che soddisfano una query.
:::
::::
:::



## b. Document-based DB: example

::: {.columns}
::: {.column width="50%"}
::: {style="font-size:70%;"}

```js
use shop;

db.utenti.insertOne({
  nome: "Luca",
  cognome: "Rossi",
  eta: 30,
  indirizzo: {
    via: "Via Roma 10",
    città: "Milano",
    cap: "20100" 
  },
  interessi: ["calcio", 
      "programmazione", "musica"],
  ordini: [
    { prodotto: "Laptop",
      prezzo: 1200,
      data: new Date("2025-09-15") 
    },
    { prodotto: "Mouse", 
      prezzo: 40, 
      data: new Date("2025-12-05") 
    } 
  ] 
});
```
:::
:::

::: {.column width="50%"}
::: {style="font-size:70%;"}
```bash
mongoimport --db shop \
  --collection utenti \
  --file utente.json \
  --jsonArray
```

\ 

"Tutti i clienti che hanno ordinato almeno 2 volte il prodotto 'Laptop' dopo il 1° gennaio 2025"
```js
db.clienti.find({
  ordini: {
    $elemMatch: {
      prodotto: "Laptop",
      quantita: { $gte: 2 },
      data_ordine: { 
        $gt: new Date("2025-01-01") 
      }
    }
  }
});
```
:::

:::
:::

## b. Document-based DB 

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Vantaggi:
  - *Schema-less*: flessibilità nelllo schema dei dati
  - Adatto a dati semi/non strutturati, con strutture non uniformi
  - Supporto a query anche molto complesse sui documenti
- Svantaggi:
  - Tendenza alla duplicazione dei dati
  - Performance possono degradare con aggregazioni complesse (e inferiori ai key-value su oggetti semplici)
:::

## c. Column-family DB

::: {.columns}
:::: {.column width="50%"}

\

![](./img/col-db.png){width="100%"}
::::

:::: {.column width="50%"}

::: {.fragment .incremental .fade-in style="font-size: 75%;"}
- Simili ai DB relazionali, ma i dati sono organizzati in famiglie di colonne piuttosto che in righe.
- I dati vengono salvati per (famiglie di ) colonna
:::

::: {.fragment .fade-in style="font-size: 75%;"}
Supporta le normali operazioni CRUD (Create, Read, Update, Delete) e query (moderatamente) complesse.
:::

::::
:::

## c. Column-family DB

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Vantaggi:
  - Ottimizzati per query su insiemi di colonne specifiche.
  - Grande scalabilità orizzontale
  - Archiviazione efficiente di dati sparsi e per timeseries
- Svantaggi:
  - Complessità nella progettazione iniziale dello schema
  - Scarsa flessibilità per tutto ciò che va oltre a le operazioni previste in fase di progettazione
  - Se i dati sono altamente relazionati, meglio un db relazionale
:::

## d. Graph-based DB

::: {.fragment .incremental .fade-in style="font-size: 75%;"}
- I dati sono organizzati come **nodi** (entità) e **archi** (relazioni) che li collegano.
- Ogni nodo e arco può avere proprietà associate.
- Ottimizzati per interrogare e navigare relazioni complesse tra entità.
:::
::: {.fragment .fade-in style="font-size: 75%;"}
Esempio di operazioni:

- CREATE (node): crea un nuovo nodo.
- MATCH (pattern): trova nodi/relazioni che soddisfano un pattern.
- CREATE (node1)-[relation]->(node2): crea una relazione tra nodi.
:::


## d. Graph-based DB: example
::: {.columns}
::: {.column width="50%"}
::: {style="font-size:65%;"}
```cypher
// Creazione di nodi
CREATE (luca:Persona {
  nome: "Luca", 
  età: 30
})
CREATE (maria:Persona {
  nome: "Maria", 
  età: 28
})
CREATE (pizza:Ristorante {
  nome: "Pizzeria Da Gino", 
  cucina: "Italiana"
})

// Creazione di relazioni
CREATE (luca)-[:AMICO_DI]->(maria)
CREATE (luca)-[:HA_VISITATO {
  data: "2025-11-20"
}]->(pizza)
CREATE (maria)-[:LAVORA_IN]->(pizza)
```
:::
:::
::: {.column width="50%"}
::: {style="font-size:65%;"}
```cypher
// Query: "Trova tutti gli amici 
// degli amici di Luca"

MATCH (luca:Persona {nome: "Luca"})
      -[:AMICO_DI]->(:Persona)
      -[:AMICO_DI]->(amico)
RETURN amico.nome

// Query: "Trova ristoranti visitati 
// da amici di Luca dove lavorano 
// altri suoi amici"

MATCH (luca:Persona {nome: "Luca"})
      -[:AMICO_DI]->(amico)
      -[:HA_VISITATO]->(ristorante)
      <-[:LAVORA_IN]-(collega)
      <-[:AMICO_DI]-(luca)
RETURN DISTINCT ristorante.nome, 
       collega.nome
```
:::
:::
:::

## d. Graph-based DB
::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Vantaggi:
  - Eccellenti per dati altamente interconnessi (social network, recommendation systems, fraud detection)
  - Query su relazioni multi-livello molto efficienti
  - Schema flessibile: facile aggiungere nuove relazioni
- Svantaggi:
  - Non ottimali per operazioni analitiche su grandi volumi di dati
  - Curva di apprendimento più ripida (linguaggi specifici come Cypher)
:::

## e. In-memory DB

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Implementazione di uno dei modelli di dati precedenti (key-value, document-based, ...)
- La differenza è che **i dati sono memorizzati nella memoria pirncipale (RAM)** anziché su archiviazione
- I dati sono volatili: si perdono in caso di spegnimento del sistema
- Alcune implementazioni offrono anche meccanismi di persistenza
:::

## e. In-memory DB
::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Vantaggi:
  - Velocità di accesso ai dati estremamente elevata
  - Ottimali per applicazioni che richiedono bassa latenza (caching, session management, real-time analytics)
- Svantaggi:
  - Limitazioni di capacità legate alla quantità di RAM disponibile
  - Non adatti per dati che richiedono persistenza a lungo termine senza meccanismi di backup
:::

# Database a confronto

## Quale strumento scegliere?

::: {.columns}
:::: {.column  width="50%"}
::: {.fragment .fade-in }

![](./img/minecraft-piccone.png){width="35%" style="display: block; margin-left: auto; margin-right: auto;"}

\ 

\



![](./img/minecraft-spada.webp){width="35%" style="display: block; margin-left: auto; margin-right: auto;"}
:::
::::

:::: {.column  width="50%"}

::: {.fragment .fade-in }
![](./img/minecraft-diamante.png){width="30%" style="display: block; margin-left: auto; margin-right: auto;"}

\

![](./img/minecraft-zombie.png){width="30%" style="display: block; margin-left: auto; margin-right: auto;"}
:::
::::

:::

## Quale strumento scegliere? 

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Non esiste una soluzione migliore sempre per tutti i casi.
- Ci sono casi in cui un DB relazionale è la scelta migliore, altri in cui un DB No-SQL è più adatto.
- Occorre valutare attentamente i requisiti dell'applicazione e scegliere il miglior trade-off tra vantaggi e svantaggi di ciascuna soluzione.
:::

## Il concetto di scalabilità:

::: {.r-stack .fade-in}
![](img/scalabilita-no-scale.png){.fragment width="100%"}

![](img/scalabilita-verticale.png){.fragment width="100%"}

![](img/scalabilita-orizzontale.png){.fragment width="100%"}
:::

## Il concetto di scalabilità:

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- **Scalabilità verticale**: aumentare le risorse (CPU, RAM, storage) di un singolo nodo/server:
    - Più semplice da implementare
    - Costi più elevati a lungo termine
    - Limiti fisici delle risorse hardware
- **Scalabilità orizzontale**: aggiungere più nodi/server al sistema, distribuendo il carico di lavoro tra di essi.
    - Maggiore flessibilità, ma introduce complessità nella gestione
    - Può essere più economico di scalare in verticale
    - Limitazioni legate alle performance di rete
:::

## Come scalano i DB?

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- DB relazionali: 
   - Scalabilità verticale ottima: aggiungendo risorse ad un singolo nodo si ottengono buone performance.
   - Scalare su più nodi è complesso, richiede tecniche come sharding e replica e non porta a vantaggi in perfomance (ma può aiutare in disponibilità e tolleranza ai guasti).
- No-Sql:
   - La maggiorparte sono progettati per scalare orizzontalmente in modo nativo.
   - Non è garantito che scalino altrettanto bene in verticale.
:::

## Consistenza, disponibilità e tolleranza alle partizioni

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
In un contesto distribuito:

- ***Consistenza***:  (***C*** - Consistency) tutti i nodi hanno la stessa copia dei dati in ogni momento.
  - I dati saranno sempre aggiornati e coerenti.
  - Qualsiasi sia il server che risponde ad una richiesta, otterrò la medesima risposta.
:::

## Consistenza, disponibilità e tolleranza alle partizioni

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
In un contesto distribuito:

- ***Disponibilità***:  (***A*** - Availability) ogni richiesta riceve sempre una risposta, anche in caso di guasti di uno o più nodi.
  - Il sistema è sempre operativo e risponde alle richieste.
  - La risposta può anche essere un errore, ma non ci saranno mai timeout.

:::

## Consistenza, disponibilità e tolleranza alle partizioni

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
In un contesto distribuito:

- ***Tolleranza alle partizioni***:  (***P*** - Partition Tolerance) Il sistema continua a funzionare correttamente anche in caso di problemi di comunicazione o guasti di alcuni nodi.
  - Il sistema deve poter prevenire problemi di *split-brain*.
  - Nodi isolati devono sapere se sono isolati e agire di conseguenza.
:::

## CAP theorem

::: {.callout-note title="Teorema di Brewer (CAP Theorem)"}
In un sistema distribuito, si possono garantire *al massimo due* delle seguenti proprietà contemporaneamente: 

- Consistenza (C)
- Disponibilità (A)
- Tolleranza alle partizioni (P)
:::


## CA: Consistenza + Disponibilità

::: {.columns}

:::: {.column width="50%"}
::: {.fragment .incremental .fade-in }
Il sistema risponde sempre alle richieste e garantisce che le risposte siano sempre consistenti. 

Esempio: database relazionali tradizionali in singolo nodo.
:::
::::

:::: {.column width="50%"}

\ 

\ 

![](img/cap-ca.png){width="100%"}
::::
:::


## CP: Consistenza + Tolleranza alle partizioni

::: {.columns}
:::: {.column width="50%"}
::: {.fragment .incremental .fade-in }
Il sistema garantisce che i dati siano sempre consistenti e tollera le partizioni di rete, al costo di una possibile riduzione della disponibilità.

Esempi:
 - DB relazioali diponibili (e.g, HA PostgreSQL)
 - MongoDB, Redis, ....

:::
::::
:::: {.column width="50%"}

\

![](img/cap-cp.png){width="100%"}
::::
:::

## AP: Disponibilità + Tolleranza alle partizioni

::: {.columns}
:::: {.column width="50%"}
::: {.fragment .incremental .fade-in }
Il sistema è sempre disponibile e tollera le partizioni di rete, ma non garantisce che i dati siano sempre consistenti.
Generalmente implementano il paradigma BASE.

Esempi:
 - Cassandra, CouchDB, DynamoDB, ...
:::
::::
:::: {.column width="50%"}

\

![](img/cap-ap.png){width="100%"}
::::
:::

## Mole di dati 

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
I database No-sql nascono per gestire grandi moli di dati, i famosi "Big Data".

I Big Data sono caratterizzati dalle cosiddette 5 V:

- Volume
- Velocità
- Varietà
- Veridicità
- Valore
:::

## Perhcè può essere un problema?

::: {.fragment .fade-in style="font-size: 80%;"}
- I db relazionali possono avere problemi di performance nel caso di grandi moli di dati o richieste ad alta velocità.
:::


::: {.fragment style="font-size: 50%;"}
| Numero di righe (per tabella) | Stato del DB relazionale         | Cosa succede                                                                         | Perché diventa critico                                                                          |
| ----------------------------: | -------------------------------- | ------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------- |
|  1M–10M | OK    | Performance accettabili con indici ben progettati                                    |                                                                     |
|   10M–100M | Quasi OK         | Gli indici iniziano a pesare anche in RAM; query complesse degradano                 | Aumenta il costo di JOIN, VACUUM, aggiornamenti pesanti                                         |
|  100M–1B | Ottimizzazioni necessarie | Anche con indici, le query full-table diventano lente; ingest rate limitato          | Locking, I/O bottleneck, crescita WAL, necessità di partizionamento                             |
|  1B+ | Non OK        | Anche con tutte le ottimizzazioni, il modello relazionale fatica                     | Soglia dei "Big data", le performance si degradano          |
| 10B+ | Modello non adatto        | Le operazioni diventano ingestibili in verticale; limiti strutturali del relazionale | Serve un DB distribuito progettato per throughput estremi (NoSQL, column-store, time-series DB, ...) |

:::

## Quindi, come scegliere?

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Ancora una volta, non esiste una risposta univoca.

- A volte si è costretti a usare un DB relazionale per vincoli esterni (e.g., legacy systems, skill del team, ...)
- A volte si sceglie un DB No-SQL per esigenze specifiche (scalabilità, flessibilità, performance ...)
- A volte i dati impongono l'uso di una soluzione piuttosto che un altra (e.g., dati non strutturati complessi da gestire in un DB relazionale)
- Nessuno vieta ad un applicativo di usare più DBMS diversi per esigenze diverse (polyglot persistence)
- Infine, la tecnologia evolve rapidamente: ciò che è vero oggi potrebbe non esserlo domani.
:::

## Esempio

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Necesità e vincoli:

- Nessun vincolo legacy: si può scegliere liberamente
- Dati strutturati, facilmente rappresentabili in tabelle
- Volume di dati accettabile (previsti 20-40M di righe)
- Requirements:
  - Performance in insert ad alta frequeza
  - Scalabilità orizzontale/verticale 
:::

## Esempio 

![](img/questdb.png){width="80%" style="display: block; margin-left: auto; margin-right: auto;"}

# Live demo 

# E per tutti i dati che non stanno nel DB?

## Non tutti i dati stanno in un database

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
I database  sono essenziali per molte applicazioni, ma in un qualsiasi sistema informatico esistono anche altri tipi di dati e informazioni che non sono memorizzati in esso:

- Files:
  - Codice sorgente/binari delle applicazioni
  - Documentazione tecnica
  - File di configurazione
  - Log di sistema e applicazioni
  - ...
- Backup e snapshots
- ...
:::

##  Storage

::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-note title="***Def.*** Storage"}
In ambito informatico con il termine storage si identificano

- i dispositivi hardware
- i supporti per la memorizzazione
- le infrastrutture 
- i software 

dedicati alla memorizzazione non volatile di grandi quantità di informazioni in formato elettronico.
:::
:::


::: {.fragment .fade-in style="font-size: 80%;"}
::: {.callout-warning title="Nota"}
Gli stessi file che servono al corretto funzionamento di un DBMS devono essere memorizzati e archiviati in un sistema di storage adeguato.
:::
:::


## Storage: tipologie

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Possiamo classificare i sistemi di storage in alcune macro-categorie:

- *Località*:
  - ***DAS*** (Direct Attached Storage): locale
  - ***NAS*** (Network Attached Storage): in rete, condiviso
  - ***SAN*** (Storage Area Network): in rete ad alte prestazioni, con soluzioni dedicate
- *Tipologia di archiviazione*:
  - ***File-based storage***: memorizzazione basata su file system
  - ***Block-based storage***: memorizzazione a blocchi
  - ***Object-based storage***: memorizzazione basata su oggetti
:::

## Località: DAS

::: {.fragment .incremental .fade-in style="font-size: 80%;"}

I dispositivi di archiviazione (HDDs, SSDs, NVMes, ...) sono direttamente collegati al computer/server che li utilizza.

- Vantaggi:
  - Bassa latenza
  - Semplicità di gestione
- Svantaggi:
  - Scalabilità orizzontale inesistente
  - Limiti fisici alla capacità totale di archiviazione
  - Mancanza di condivisione dei dati tra più sistemi
  - SPOF (Single Point of Failure) per definizione
:::

## Località: NAS

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Un server di archiviazione dedicato è collegato alla rete e espone lo spazio di archiviazione come condivisione di rete (e.g., NFS, SMB/CIFS).

- Vantaggi:
  - Condivisione dei dati tra macchine diverse possibile
  - Moderata facilità di gestione
  - Costi inferiori rispetto a SAN
- Svantaggi:
  - Passando attraverso la rete, si introduce latenza
  - Capacità totale di archiviazione da dividere tra più clients
  - Rimane un singolo punto di guasto 
:::

## Località: SAN

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Un ***cluster*** di macchine dedicate all'archiviazione, solitamente collegate tramite reti ad alte prestazioni (e.g., Fibre Channel, infiniband, ISCSI, ...).

- Vantaggi:
  - Elevate performance in lettura/scrittura (spesso possibilità di parallelismo)
  - Scalabilità orizzontale
  - Alta disponibilità e tolleranza ai guasti
  - Ridondanza dei dati su più nodi
- Svantaggi:
  - Costi elevati
  - Maggiore complessità di gestione e manutenzione
:::

## Tipologia di archiviazione: File-based

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
I dati sono memorizzati come file all'interno di un file system (e.g , ext4, NTFS, ZFS, ext4, APFS, ...).

- Vantaggi:
  - Semplicità di utilizzo e gestione
  - Compatibilità con la maggior parte dei sistemi operativi
- Svantaggi:
  - Performance limitate per operazioni ad alta velocità
  - Scalabilità orizzontale limitata
:::

## Filesy stem: definizione

::: {.callout-note title="***Def.*** File System"}
Un **file system** è una struttura logica e un insieme di regole utilizzate da un sistema operativo per organizzare, memorizzare e gestire i file su un dispositivo di archiviazione.

La strruttura logica di un file system è generalmente ad albero o a grafo, con directory (cartelle) che contengono file e altre directory.

Un file system gestisce anche i metadati associati ai file, come permessi di accesso, timestamp di creazione/modifica, dimensioni, ecc.
:::

## Tipologia di archiviazione: Block-based

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
I dati sono memorizzati in blocchi di dimensioni fisse (e.g., 512 byte, 4 KB, ...), che possono essere letti o scritti indipendentemente.

- Vantaggi:
  - Elevate performance per operazioni di lettura/scrittura casuali
  - Maggiore flessibilità nella gestione dello spazio di archiviazione
- Svantaggi:
  - Maggiore complessità di gestione
  - Richiede software specifico per l'accesso ai dati
  - Non direttamente montabile come un file system tradizionale
:::

## Tipologia di archiviazione: Object-based

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
I dati sono memorizzati come oggetti, ciascuno con un identificatore univoco e metadati associati.
- Vantaggi:
  - Scalabilità orizzontale eccellente
  - Adatto per grandi moli di dati non strutturati
  - Facilità di integrazione con applicazioni cloud-native
- Svantaggi:
  - Performance inferiori per operazioni ad alta velocità rispetto a block-based storage
  - Maggiore latenza nell'accesso ai dati
  - Servono API specifiche per l'accesso agli oggetti
  - Non direttamente montabile come un file system tradizionale
:::

## RAID

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
::: {.callout-note title="***Def.*** RAID (Redundant Array of Independent/Inexpensive Disks)"}
Tecnologia che combina più dischi rigidi in un'unica unità logica per migliorare le performance e/o la ridondanza dei dati.
:::
:::

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
::: {.callout-warning title="Il RAID non è un backup!"}
Un errore comune è pensare che avere un array RAID equivalga ad avere un backup dei dati.

In realtà, il RAID protegge solo contro il guasto di uno o più dischi fisici, ma non protegge contro:
- Guasti dell'intero sistema
- Corruzione dei dati
:::
:::

## Raid 0: Striping

I dati sono suddivisi in blocchi e distribuiti equamente su tutti i dischi dell'array.

::: {.columns}
:::: {.column width="50%"}
![](img/raid0.png){width="70%"}
::::
:::: {.column width="50%"}
::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Numero minimo di dischi: 2
- Velocità in lettura e scrittura proporzionale al numero di dischi (fino a N×)
- Capacità totale: somma delle capacità di tutti i dischi
- Tolleranza ai guasti: nessuna (se un disco fallisce, si perdono tutti i dati)
:::
::::
:::

## Raid 1: Mirroring

I dati sono duplicati identicamente su due o più dischi.

::: {.columns}
:::: {.column width="50%"}
![](img/raid1.png){width="70%"}
::::
:::: {.column width="50%"}
::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Numero minimo di dischi: 2
- Velocità di scrittura pari a quella di un singolo disco
- Velocità di lettura fino a N volte più veloce (lettura parallela)
- Capacità totale: capacità del disco più piccolo
- Tolleranza ai guasti: può tollerare il guasto di N-1 dischi (basta che uno resti operativo)
:::
::::
:::

## Raid 5: Striping con parità distribuita

I dati sono suddivisi in blocchi su tutti i dischi, con un blocco di parità distribuito.

::: {.columns}
:::: {.column width="50%"}
![](img/raid5.png){width="100%"}
::::
:::: {.column width="50%"}
::: {.fragment .incremental .fade-in style="font-size: 75%;"}
- Numero minimo di dischi: 3
- Lettura fino a (N-1)× più veloce
- Scrittura più lenta a causa del calcolo e aggiornamento della parità
- Capacità totale: somma delle capacità di tutti i dischi meno la capacità di un disco
- Tolleranza ai guasti: può tollerare il guasto di un solo disco
:::
::::
:::

## Combinazioni delle precedenti

È possibile combinare i livelli RAID per ottenere un compromesso tra performance e affidabilità.

::: {.columns}
:::: {.column width="50%"}
![](img/raid0+1.png){width="100%"}
::::
:::: {.column width="50%"}
::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Esempio: RAID 0+1 (striping + mirroring)

- I dati sono suddivisi in blocchi e distribuiti su più dischi (RAID 0)  
- L’intero array RAID 0 è poi duplicato su un secondo set di dischi (RAID 1)
- Offre performance simili al RAID 0 con la ridondanza del RAID 1
:::
::::
:::

## RAID: serve davvero?

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- RAID può miglioare le performance e/o la ridondanza dei dati, ma non sostituisce una strategia di backup adeguata.
- Con l'avvento di SSDs e NVMe, alcuni vantaggi del RAID (soprattutto in termini di performance) sono meno rilevanti.
- In molti casi, soluzioni di storage moderne *SAN* offrono già ridondanza e performance elevate senza la necessità di configurare RAID a livello di singolo server.

Se dovessi scegliere oggi, lo adotterei solo in contesti specifici: (NAS o DAS)
:::

## 3R da non dimenticare mai

::: {.incremental .fade-in style="font-size: 80%;"}
::: {.callout-note title="1. Replica"}
La ***replica*** è la creazione di copie identiche dei dati su diversi dispositivi di storage
:::
:::

::: {.incremental .fade-in style="font-size: 80%;"}
::: {.callout-note title="2. Ridondanza"}
La ***ridondanza*** è la duplicazione di componenti critici del sistema (dati, dischi, nodi, interfacce, alimentazioni, ecc.) per garantire la continuità operativa in caso di guasti.
:::
:::

::: {.incremental .fade-in style="font-size: 80%;"}
::: {.callout-note title="3. Resilienza"}
La ***resilienza*** è la capacità del sistema di recuperare rapidamente da guasti o interruzioni, minimizzando l'impatto sui dati e sulle operazioni.

Non è una tecnologia specifica, ma una proprietà emergente di un sistema che incorpora replica e ridondanza.
:::
:::


# Storage - alcuni esempi

##

::: {.fragment .incremental .fade-in}
Analizziamo brevemente 3 soluzioni di storage molto diffuse:

- **1. Local Storage**
- **2. Rete aziendale con NFS**
- **3. Ceph**

:::


## 1. Local Storage

::: {.fragment .incremental .fade-in style="font-size: 70%;"}
Scenario tipico: ogni dipendente ha una workstation aziendale con storage locale (HDD, SSD, ...).

- Costi di gestione nulli
- L'user non ha bisogno di connettività di rete per accedere ai propri dati
- Performance di lettura/scrittura limitate solo dalla qualità dell'hardware utilizzato

![](img/grid-users.png){.fragment width="50%" style="display: block; margin-left: auto; margin-right: auto;"}
:::

## 1. Local Storage

::: {.fragment .incremental .fade-in style="font-size: 80%;"}

- E se due utenti devono collaborare su uno stesso file?
- E se l'utente perde il suo computer o si rompe?
- E se l'utente dimentica di fare il backup dei suoi dati?
- E se l'utente ha bisogno di accedere agli stessi dati da altri dispositivi? (Per es. da un server di calcolo a cui invia dei job)?

:::

:::  {.fragment .fade-in style="font-size: 80%;"}
Alcuni problemi possono essere mitigati con soluzioni tampone (es. usare un server git) ma non risolvono i problemi alla radice.

In generale si addossa la responsabilità di prevenire data losses all'utente finale, il che non è mai una buona idea.
:::


## 2. Rete aziendale con NFS

::: {.fragment .incremental .fade-in style="font-size: 70%;"}
Scenario tipico: un server dedicato espone uno spazio di archiviazione condiviso tramite NFS (Network File System).

- I dati sono centralizzati e accessibili da qualsiasi macchina connessa alla rete aziendale
- Facilità di gestione e backup centralizzato
- Occorre avere una buona connettività di rete per performance accettabili

![](img/nfs.png){width="70%" style="display: block; margin-left: auto; margin-right: auto;"}
:::

## 2. Rete aziendale con NFS

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Possibilità di collaborare a progetti da diverse workstation
- Centralizzazione dei dati $\Rightarrow$ maggiore semplicità di backup
- Il server NFS può implementare RAID o altre tecniche di ridondanza
:::
::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Tuttavia...

- Rimane un singolo punto di guasto (SPOF)
- Il server espone un file system montato dai clients, nulla di più
:::


## 3. Ceph

::: {.columns}

:::: {.column width="50%"}

::: {.fragment .incremental .fade-in style="font-size: 65%;"}
- Software di storage distribuito open-source
- Progettato per scalare orizzontalmente su cluster di server
- Buone performance grazie alla parallelizzazione delle operazioni di I/O
- Soluzione estremamente robusta e tollerante ai guasti, con meccanismi di replica e auto-riparazione
- **Richiede una cluster di storage dedicato ed adeguato**
- Decisamente meno banale da setuppare e gestire rispetto alle soluzioni precedenti, ma molto più potente e versatile
:::

::::
:::: {.column width="50%"}
![](img/ceph-logo.png){width="50%" style="display: block; margin-left: auto; margin-right: auto;"}

\ 

![](img/schema-ceph.png){width="75%"}

::::
:::

## Ceph

\

![](img/schema-workstation-ceph.png){width="80%" style="display: block; margin-left: auto; margin-right: auto;"}

## Ceph: internals

![](img/ceph-internals.png){width="80%" style="display: block; margin-left: auto; margin-right: auto;"}

## Ceph

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
- Gli user possono accedere ai dati da qualsiasi macchina connessa alla rete aziendale
- I dati sono distribuiti su più nodi di storage, permettendo parallelismi che migliorano le performance
- Ceph grazie a `librados` può essere utilizzato sia come file system montato (CephFS) sia come object storage (RADOS) che come block storage (RBD)
:::

::: {.fragment .incremental .fade-in style="font-size: 80%;"}
Tuttavia ...

- Richiede una infrastruttura di storage dedicata e adeguata
:::

## Qualche considerazione

::: {.fragment .fade-in style="font-size: 75%;"}
Scegliere la soluzione di storage più adatta è come scegliere il database più adatto...
:::

::: {.fragment .fade-in style="font-size: 75%;"}

\ 

***Dipende dal contesto, dai requisiti e dai vincoli specifici dell'organizzazione o dell'applicazione in questione.***
:::


## Qualche considerazione 
::: {.fragment .incremental .fade-in style="font-size: 75%;"}
Alcuni aspetti (non approfonditi) da considerare:

- Sicurezza dei dati (crittografia, access control, ...)
- Compliance normativa (GDPR, HIPAA, ...)
- Costi di gestione e manutenzione
- Facilità di integrazione con l'infrastruttura esistente
- **Backup & Snapshots** ed annesse procedure di disaster recovery
- **Località** dei dati (on-premises, cloud, ibrido)
- Performance richieste (latenza, throughput)
- Facilità di espansione futura
- ...
:::






# Grazie per l'attenzione!
  Domande?

## Licenza d'uso di questo documento

Questo documento è rilasciato sotto la licenza Creative Commons
Attribuzione - Condividi allo stesso modo 4.0 Internazionale (CC BY-SA
4.0).

\

Per leggere una copia della licenza, visita [https://creativecommons.org/licenses/by-sa/4.0/deed.it](https://creativecommons.org/licenses/by-sa/4.0/deed.it) o invia una lettera a Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

![](img/CCBYSA.png){width="0.05%" style="display: block; margin-left: auto; margin-right: auto;"}